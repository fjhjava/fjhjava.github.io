<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Myabtis 3.4.1源码分析之总体流程]]></title>
      <url>http://yoursite.com/2016/09/05/Mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
      <content type="html"><![CDATA[<p>前言：MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。<br><a id="more"></a><br>总体流程</p>
<p>(1)加载配置并初始化</p>
<p>触发条件:加载配置文件</p>
<p>将SQL的配置信息加载成为一个个MappedStatement对象(包括了传入参数映射配置、执行的SQL语句、结果映射配置)，存储在内存中。</p>
<p>(2)接收调用请求</p>
<p>触发条件:调用Mybatis提供的API</p>
<p>传入参数:为SQL的ID和传入参数对象</p>
<p>处理过程:将请求传递给下层的请求处理层进行处理。</p>
<p>(3)处理操作请求 触发条件:API接口层传递请求过来</p>
<p>传入参数:为SQL的ID和传入参数对象</p>
<p>处理过程:</p>
<p>(A)根据SQL的ID查找对应的MappedStatement对象。</p>
<p>(B)根据传入参数对象解析MappedStatement对象，得到最终要执行的SQL和执行传入参数。</p>
<p>(C)获取数据库连接，根据得到的最终SQL语句和执行传入参数到数据库执行，并得到执行结果。</p>
<p>(D)根据MappedStatement对象中的结果映射配置对得到的执行结果进行转换处理，并得到最终的处理结果。</p>
<p>(E)释放连接资源。</p>
<p>(4)返回处理结果将最终的处理结果返回。</p>
<p>来源:<a href="http://baike.so.com/doc/5582692-5795562.html" target="_blank" rel="external">Mybatis360百科</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于webservice框架cxf遇到的一些问题]]></title>
      <url>http://yoursite.com/2016/09/01/Apache%20CXF%E8%AF%A6%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<p>关于webservice框架cxf遇到的一些问题</p>
<p>代码贴上：<br>import org.apache.cxf.jaxws.JaxWsServerFactoryBean;</p>
<p>import com.java1234.service.HelloWorld;<br>import com.java1234.service.impl.HelloWorldImpl;<br><a id="more"></a><br>public class Server {</p>
<pre><code>public static void main(String[] args) {
    System.out.println(&quot;webservice start!&quot;);
    HelloWorld helloWorldImpl = new HelloWorldImpl();
    String address = &quot;http://192.168.0.101/hello?wsdl&quot;;
    // Endpoint.publish(address, helloWorldImpl);
    JaxWsServerFactoryBean factoryBean = new JaxWsServerFactoryBean();
    factoryBean.setAddress(address);
    factoryBean.setServiceClass(HelloWorld.class);
    factoryBean.setServiceBean(helloWorldImpl);
    factoryBean.create();
    System.out.println(&quot;webservice started!&quot;);
}
</code></pre><p>}</p>
<p>警告: Interceptor for {<a href="http://impl.service.test.com/}TestService" target="_blank" rel="external">http://impl.service.test.com/}TestService</a> has thrown exception, unwinding now<br>org.apache.cxf.interceptor.Fault: No binding operation info while invoking unknown method with params unknown.</p>
<p>解决方式:<br>将访问地址修改为<a href="http://localhost:8080/cxf/TestService?wsdl即可加入了?wsdl" target="_blank" rel="external">http://localhost:8080/cxf/TestService?wsdl即可加入了?wsdl</a></p>
<p>警告: Interceptor for {<a href="http://impl.service.test.com/}TestService" target="_blank" rel="external">http://impl.service.test.com/}TestService</a> has thrown exception, unwinding now<br>org.apache.cxf.binding.soap.SoapFault: A SOAP 1.2 message is not valid when sent to a SOAP 1.1 only endpoint.</p>
<p>原因是soap协议不匹配，要使用soap1.2协议<br>在接口或实现类上声明，注意要引入geronimo-jaxws_2.2_spec-1.0.jar包<br>@BindingType(value = “<a href="http://www.w3.org/2003/05/soap/bindings/HTTP/" target="_blank" rel="external">http://www.w3.org/2003/05/soap/bindings/HTTP/</a>“) 或<br>@BindingType(value = SOAPBinding.SOAP12HTTP_BINDING)</p>
<p>cxf 做webservice客户端使用soap1.2协议</p>
<jaxws:client id="cdsPatientServices" address="http://localhost:8181/cxf/v1/soap/patient" bindingid="http://www.w3.org/2003/05/soap/bindings/HTTP/" serviceclass="net.carefx.cds.v1.service.patientservices.CdsPatientServices">
</jaxws:client>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用Genymotion代替原生模拟器]]></title>
      <url>http://yoursite.com/2016/08/25/%E4%BD%BF%E7%94%A8Genymotion%E4%BB%A3%E6%9B%BF%E5%8E%9F%E7%94%9F%E6%A8%A1%E6%8B%9F%E5%99%A8.html</url>
      <content type="html"><![CDATA[<p>用过Eclipse开发的Android工程师都知道原生的模拟器非常NB啊，每次出场就跟古代的大姑娘上轿一样，要先打扮好，然后迈着三寸金莲慢慢悠悠出来，实在受不了了，所以干脆找个可替代的产品吧，想起前阵子在微博上看到的Genymotion，于是今天就直接用上了，果断速度杠杠滴啊，写android的小伙伴们可以果断走起了，注意：mac下写android的小伙伴要耐心点儿，如果你升级了10.9的话，会有意想不到的兼容性问题发生，本人血的教训已经可以足够作为证明了。<br>准备工作<br>首先到Genymotion官网上注册一个账号，传送门在此，注意，该账号并非只用于下载所需程序，还会在你新建不同的Devices时要用到，所以要记牢。注册完账号之后，登录，然后就可以直接到下载页面（下载传送门在此）去下载你所需要的东西了，基本上我们需要如下的几个程序或者插件：<br>VirtualBox(win系统下Genymotion官方有Genymotion Installer With VirtualBox版本的，可直接下载，mac osx或者Linux系统需要单独安装VirtualBox)<br>Genymotion Installer<br><a id="more"></a><br>当然，还需要额外的Eclipse或者IntelliJ IDEA的插件，这个可以下载完再安装，也可以直接在线安装。<br>准备就绪之后就开始一路next安装完Genymotion Installer，然后打开Genymotion程序，如下图：<br>[图片]</p>
<p>点击Settings，指定下你的android的SDK位置，我自己的电脑上安装了Android Studio和Eclipse，所以这里通用了同一个SDK，如下图：<br>[图片]</p>
<p>完成了之后，接下来，我们还要在Eclipse中安装相对应的插件：<br>点击Help-&gt;Install New Software, 输入如下网址，<a href="http://plugins.genymotion.com/eclipse，然后安装即可。" target="_blank" rel="external">http://plugins.genymotion.com/eclipse，然后安装即可。</a><br>然后我们就会发现在Eclipse中多了这么一个按钮，这个就是Genymotion的Virtual Device Manager按钮<br>[图片]</p>
<p>接下来，我们打开安装好的Genymotion的程序，点击add，添加一个设备，会弹出提示需要登录，输入文章开始的时候我们创建的账号和密码，然后在列表中选择我们要添加的设备信息，点击右下角的Add按钮即可添加一个设备。<br>需要注意的一点就是，Genymotion模拟器访问网络和原生的Android模拟器是不一样的，因为Genymotion模拟器是运行在VirtualBox虚拟机上的x86架构的Android版本（这也是它的开机速度远胜于原生模拟器的原因吧），所以如果你的应用需要联网的话，那么你需要查看一下你的VirtualBox的虚拟网卡了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[分治算法]]></title>
      <url>http://yoursite.com/2016/08/25/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95.html</url>
      <content type="html"><![CDATA[<p>算法描述：<br>使用分治算法设计程序，一般按以下步骤进行：<br>（1）分解：将要求解的问题划分成若干规模较小的同类问题<br>（2）求解：当子问题划分的足够小时，用较简单的方法解决<br>（3）合并：按求解的问题要求，将子问题的解逐层合并，即可构成问题的最终解答</p>
<p>比赛赛程安排：<br> 四名选手，三天可以比完<br>选手\时间第一天第二天第三天1234214334124321<br><a id="more"></a><br>划分两个选手 ，一天就可以比完<br>选手\时间第一天1221</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Scala简介]]></title>
      <url>http://yoursite.com/2016/08/25/Scala%E7%AE%80%E4%BB%8B.html</url>
      <content type="html"><![CDATA[<p>Scala语言，函数式编程语言。</p>
<p>一、安装Scala语言<br>    前往scala官网下载对应的系统版本，我的是windows7 64位系统<br>    下载好scala-2.11.8.msi,直接点击安装。<br>    一路下去Next…<br>二、基础语法<br>    值引用透明，完美的分布式编程语言。</p>
<a id="more"></a>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JIT编译器(虚拟机)]]></title>
      <url>http://yoursite.com/2016/08/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%20(JNI%E3%80%81%E4%B8%89%E5%A4%A7%E5%95%86%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA).html</url>
      <content type="html"><![CDATA[<blockquote>
<p>JIT编译器，英文写作Just-In-Time Compiler，中文意思是即时编译器.</p>
</blockquote>
<p>在Java编程语言和环境中，即时编译器(JIT compiler，just-in-time compiler)是一个把Java的字节码(包括需要被解释的指令的程序)转换成可以直接发送给处理器的指令的程序。当你写好一个Java程序后，源语言的语句将由Java编译器编译成字节码，而不是编译成与某个特定的处理器硬件平台对应的指令代码(比如，Intel的Pentium微处理器或IBM的System/390处理器)。字节码是可以发送给任何平台并且能在那个平台上运行的独立于平台的代码。<br><a id="more"></a></p>
<blockquote>
<p>事实上，JIT编译器分成两种:经济编译器和普通编译器。</p>
</blockquote>
<p>折叠 经济JIT编译器<br>经济JIT编译器代表了运行一个.NET应用程序所需要的最少功能，它直接用对等的本机代码取代每一条MSIL指令，不进行任何优化从而也带来更少的系统负载。这也意味着它主要应用在内存等资源比较紧张的平台上。<br>折叠 普通JIT编译器<br>普通JIT编译器则是缺省的运行时配置，它会对其产生的代码进行即时优化。这样做无形中给予了.NET超出传统预编译语言的一个优点:预编译语言只能对其处理的代码将要运行于其上的平台做一番大致的事前估计。<br>JIT编译器可以经过准确调节达到当前运行时状态，结果可以完成一些预编译语言无法完成的工作:更高效地利用和分配CPU寄存器。在适当的情况下实施低级代码优化，比如常量重叠、拷贝复制、取消范围检查、取消常规副表达式以及方法内联等</p>
<p>在代码执行期间监控当前的物理和虚拟内存需求从而更高效地利用内存<br>产生特定的平台指令以准确、充分地利用实际的处理器模式<br>NET编译的结果就是JIT所带来的额外负载要求并没有产生显著的性能损失。<br>折叠 Java中的JIT</p>
<blockquote>
<p>JIT Compiler(Just-in-time Compiler) 即时编译</p>
</blockquote>
<p>最早的Java建置方案是由一套转译程式(interpreter)，将每个Java指令都转译成对等的微处理器指令，并根据转译后的指令先后次序依序执行，由于一个Java指令可能被转译成十几或数十几个对等的微处理器指令，这种模式执行的速度相当缓慢。 针对这个问题，业界首先开发出JIT(just in time)编译器。当Java执行runtime环境时，每遇到一个新的类别(class:类别是Java程式中的功能群组)，类别是Java程式中的功能群组-JIT编译器在此时就会针对这个类别进行编译(compile)作业。经过编译后的程式，被优化成相当精简的原生型指令码(native code)，这种程式的执行速度相当快。花费少许的编译时间来节省稍后相当长的执行时间，JIT这种设计的确增加不少效率，但是它并未达到最顶尖的效能，因为某些极少执行到的Java指令在编译时所额外花费的时间可能比转译器在执行时的时间还长，针对这些指令而言，整体花费的时间并没有减少。 基于对JIT的经验，业界发展出动态编译器(dynamic compiler)，动态编译器仅针对较常被执行的程式码进行编译，其余部分仍使用转译程式来执行。也就是说，动态编译器会研判是否要编译每个类别。动态编译器拥有两项利器:一是转译器，另一则是JIT，它透过智慧机制针对每个类别进行分析，然后决定使用这两种利器的哪一种来达到最佳化的效果。动态编译器针对程式的特性或者是让程式执行几个循环，再根据结果决定是否编译这段程式码。这个决定不见得绝对正确，但从统计数字来看，这个判断的机制正确的机会相当高。事实上，动态编译器会根据「历史资料」做决策，所以程式执行的时间愈长，判断正确的机率就愈高。以整个结果来看，动态编译器产生的程式码执行的速度超越以前的JIT技术，平均速度可提高至50%。</p>
<blockquote>
<p>JIT 页面渲染引擎</p>
</blockquote>
<p>JIT 页面渲染是 COMSHARP CMS 为了实现网站内容即时更新而开发的页面生成技术，JIT页面渲染引擎直接从数据库获取网站最新内容，瞬间生成页面输出给访问者，并通过 URL 转写技术实现纯静态地址。JIT 页面渲染技术是针对传统 CMS 生成静态 HTML 文件而言。传统 CMS 由于使用脚本代码模板技术，页面生成前，需要将数据库中的页面内容用外部模板进行解析与渲染，导致严重的性能问题，为了解决这个问题，传统 CMS 一般采用生成 HTML 静态文件技术，即，在内容创作完成后，对全站的内容执行一个静态 HTML 文件生成过程，最终，全站内容以静态 HTML 文件的形式存在。 静态 HTML 文件技术最显著的优势是性能出众，然而这种技术最严重的问题在于，用户对站点任何修改与更新，必须首先经过一次全站 HTML 文件重新生成过程，然后才能被访问者看到。根据不同 CMS 产品的性能和站点规模，这个 HTML 生成过程可能长到十几分钟到几十分钟或更长。也有个别 CMS 产品使用触发式页面渲染模式，即内容更新后，并不立即生成 HTML 文件，而是在用户第一次访问该页面时，触发生成该页面的 HTML 文件，这种技术的问题在于，用户第一次访问被更新页面的时候，可能经历非常漫长的等待，因为站点内各个页面之间并非孤立的，他们可能相互引用，虽然访问的只是一个页面，为了对引用页面同步更新，需要重新生成 HTML 文件的页面可能有多个。 JIT 页面渲染如何工作? 下图，是 COMSHARP CMS JIT 渲染引擎与传统 CMS 生成 HTML 静态页面模式对比。可以看出，JIT 渲染引擎直接将网站最新内容从数据库渲染给访问用户，而传统 CMS 的站点内容在到达访问用户之前，首先要经历一个 HTML 的转换过程。COMSHARP CMS JIT 页面渲染如何实现毫秒级的渲染速度? COMSHARP CMS 在页面渲染的时候，JIT 引擎可以在数十毫秒的时间内容完整整个页面的生成，这样就保证用户访问的时候，不会因 JIT 渲染造成延迟。事实上，COMSHARP CMS 网站访问速度只取决于服务器带宽，页面生成过程带来的延迟可以忽略不计。 我们有两项技术保证这样的性能: 编译级主题模板 COMSHARP CMS 的编译级主题模板直接内嵌在系统的 DLL 中，主题模板的套用是在运行时(Run Time)完成，这和传统 CMS 的调用脚本代码模板解释运行是截然不同。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java世界里的HelloWorld]]></title>
      <url>http://yoursite.com/2016/08/21/helloworld.html</url>
      <content type="html"><![CDATA[<h1 id="HelloWorld-java"><a href="#HelloWorld-java" class="headerlink" title="HelloWorld.java"></a>HelloWorld.java</h1><p>public static void main(String[] args)</p>
<p>{<br>    System.out.println(“Hello,Java!”);</p>
<p>}<br><a id="more"></a></p>
]]></content>
    </entry>
    
  
  
</search>
